#!/usr/bin/env ruby

require 'rubygems'
require 'highline/import' # optional dep: termios
require 'trollop'

require 'larch'

module Larch

  # Parse command-line options.
  options = Trollop.options do
    version "Larch #{APP_VERSION}\n" << APP_COPYRIGHT
    banner <<EOS
Larch syncs messages from one IMAP server to another. Awesomely.

Usage:
  larch --from <uri> --to <uri> [options]

Required:
EOS
    opt :from, "URI of the source IMAP server.", :short => '-f', :type => :string, :required => true
    opt :to,   "URI of the destination IMAP server.", :short => '-t', :type => :string, :required => true

    text "\nCopy Options:"
    opt :from_folder,      "Source folder to copy from", :short => :none, :default => 'INBOX'
    opt :from_pass,        "Source server password (default: prompt)", :short => :none, :type => :string
    opt :from_user,        "Source server username (default: prompt)", :short => :none, :type => :string
    opt :to_folder,        "Destination folder to copy to", :short => :none, :default => 'INBOX'
    opt :to_pass,          "Destination server password (default: prompt)", :short => :none, :type => :string
    opt :to_user,          "Destination server username (default: prompt)", :short => :none, :type => :string

    text "\nGeneral Options:"
    # opt :dry_run,          "Don't actually do anything.", :short => '-n'
    opt :fast_scan,        "Use a faster (but less accurate) method to scan mailboxes. This may result in messages being re-copied.", :short => :none
    opt :max_retries,      "Maximum number of times to retry after a recoverable error", :short => :none, :default => 3
    opt :no_create_folder, "Don't create destination folders that don't already exist", :short => :none
    opt :ssl_certs,        "Path to a trusted certificate bundle to use to verify server SSL certificates", :short => :none, :type => :string
    opt :ssl_verify,       "Verify server SSL certificates", :short => :none
    opt :verbosity,        "Output verbosity: debug, info, warn, error, or fatal", :short => '-V', :default => 'info'
  end

  # Validate command-line options.
  [:from, :to].each do |sym|
    unless options[sym] =~ IMAP::REGEX_URI
      Trollop.die sym, "must be a valid IMAP URI (e.g. imap://example.com)"
    end
  end

  unless Logger::LEVELS.has_key?(options[:verbosity].to_sym)
    Trollop.die :verbosity, "must be one of: #{Logger::LEVELS.keys.join(', ')}"
  end

  # Create URIs.
  options[:from]      = URI(options[:from])
  options[:to]        = URI(options[:to])
  options[:from].path = '/' + CGI.escape(options[:from_folder].gsub(/^\//, ''))
  options[:to].path   = '/' + CGI.escape(options[:to_folder].gsub(/^\//, ''))

  # Prompt for usernames and passwords if necessary.
  unless options[:from_user]
    options[:from_user] = ask("Source username (#{options[:from].host}): ")
  end

  unless options[:from_pass]
    options[:from_pass] = ask("Source password (#{options[:from].host}): ") {|q| q.echo = false }
  end

  unless options[:to_user]
    options[:to_user] = ask("Destination username (#{options[:to].host}): ")
  end

  unless options[:to_pass]
    options[:to_pass] = ask("Destination password (#{options[:to].host}): ") {|q| q.echo = false }
  end

  # Go go go!
  init(options[:verbosity])

  Net::IMAP.debug = true if @log.level == :insane

  source = IMAP.new(options[:from], options[:from_user], options[:from_pass],
      :fast_scan   => options[:fast_scan],
      :max_retries => options[:max_retries],
      :ssl_certs   => options[:ssl_certs] || nil,
      :ssl_verify  => options[:ssl_verify])

  dest = IMAP.new(options[:to], options[:to_user], options[:to_pass],
      :create_mailbox => !options[:no_create_folder],
      :fast_scan      => options[:fast_scan],
      :max_retries    => options[:max_retries],
      :ssl_certs      => options[:ssl_certs] || nil,
      :ssl_verify     => options[:ssl_verify])

  unless RUBY_PLATFORM =~ /mswin|mingw|bccwin|wince|java/
    begin
      for sig in [:SIGINT, :SIGQUIT, :SIGTERM]
        trap(sig) { @log.fatal "Interrupted (#{sig})"; Kernel.exit }
      end
    rescue => e
    end
  end

  copy_folder(source, dest)
end
